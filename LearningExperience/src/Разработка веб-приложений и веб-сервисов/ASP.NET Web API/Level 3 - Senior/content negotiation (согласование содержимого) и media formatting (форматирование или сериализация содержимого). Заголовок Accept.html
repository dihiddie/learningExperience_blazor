<p><b>Согласование содержимого - </b>способ, позволяющий клиенту настроить ответ от сервера. Из-за того, что у ресурса может быть несколько представлений, может быть так, что есть несколько клиентов, ждущих разных предлставлений. И когда клиент запрашивает подходящее представление для себя - это и называется <b>content negotiation</b></p>
<p>Если выбор представления определяется сервером, то это <b><i>server-driven negotiation.</i></b> Если выбор делается на стороне агента/клиента, то это называется <b><i>agent-driven content negotiation</i></b></p>
<p>В случае сервера приходится делать очень много догадок насчет того, чего же захочет клиент, поэтому чаще всего этот тип не используется. Кроме этого есть целая череда причин, которые делают этот подход тяжелым и запутанным.</p>
<p>Таким образом, большинство рест апи опираются на клиентский подход, то есть на использование заголовки HTTP-запросов или шаблонов ури для ресурса</p>
<h5>Content negotiation using HTTP headers</h5>
<p>На стороне сервера к входящему запросу может быть прикреплен объект. Чтобы определить его тип, сервер использует заголовок HTTP-запроса Content-Type. Некоторыми распространенными примерами типов контента являются «text / plain», «application / xml», «text / html», «application / json», «image / gif» и «image / jpeg».</p>
<i>Content-Type: application/json</i>
<p>Так же, чтобы определить, какой тип представления требуется на стороне клиента, используется HTTP-заголовок ACCEPT. Он будет иметь одно из значений, указанных выше для Content-Type.</p>
<i>Accept: application/json</i>
<h5>Content negotiation using URL patterns</h5>
<p>Другой способ передать информацию о типе контента на сервер, клиент может использовать конкретное расширение в URI ресурса. Например, клиент может запросить подробности, используя:</p>
<p><i>http://rest.api.com/v1/employees/20423.xml</i> - вернется XML ответ</p>
<p><i>http://rest.api.com/v1/employees/20423.json</i> - вернется JSON ответ</p>

<h4>ASP NET CORE WEB API</h4>
<p>По дефолту возвращает результат в формате JSON</p>
<p>Например, чтобы настроить ответ так, чтобы он возвращал либо json/xml, надо (помним, что по дефолту json):</p>
<ul>
    <li>в ConfigureServices в AddControllers добавить разрешение на принятие заголовков</li>
    <pre><code>
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddControllers(config =&gt;
            {
                <b>
                // позволяем серверу обрабатывать заголовки от браузера
                config.RespectBrowserAcceptHeader = true;
                // если клиент попробует запросить какой то тип, который сервер не умеет обрабатывать, выкинет 406
                config.ReturnHttpNotAcceptable = true;
            </b>
            }).AddXmlDataContractSerializerFormatters();
        }
    </code></pre>
    <li>Передаем <i>Accept: text/xml</i> в заголовке запроса</li>
    <li>Ответ вернулся в формате xml</li>
</ul>

<h5>Media Formatting</h5>
<p>Выше мы посмотрели, как web api возвращает ответ в разных форматах, основываясь на заголовках Accept / Content-Type. Но как он это делает? Ответ: используя media-type formatters</p>
<p><b>media-type formatters - </b>это классы, отвечающие за сериализацию данных запроса / ответа, чтобы веб-API мог понимать формат данных запроса и отправлять данные в формате, который ожидает клиент. Веб-API включает следующие встроенные средства форматирования медиа-типов. Список стандартных форматтеров: JsonMediaTypeFormatter, XmlMediaTypeFormatter, FormUrlEncodedMediaTypeFormatter, JQueryMvcFormUrlEncodedFormatter</p>