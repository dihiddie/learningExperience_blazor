<p>Короче, возможно я поняла все неправильно. Но если вдруг вам хочется использовать перечисление не в классическом понимании, но как-то так эдако (а именно, обращаться к объекту как к массиву, то для этого нам нужен итератор. А чтобы получить итератор, нужно реализовать метод, возвращающий IENumerator</p>
<pre><code>  class Program
    {
        static void Main(string[] args)
        {
            Numbers numbers = new Numbers();
            // foreach (int n in numbers) Console.WriteLine(n);

            foreach (string n in numbers.GetItems()) Console.WriteLine(n);

            Console.ReadKey();
        }
    }

    public class Numbers
    {
        public IEnumerator GetEnumerator()
        {
            for (int i = 0; i &lt; 6; i++) yield return i * i;
        }
    }</code></pre>
<p>Классно.Что здесь интересного? Оператор yield return возвращает элемент коллекции в итераторе и перемещает текущую позицию на следующий элемент. Наличие оператора yield return превращает метод в итератор. Каждый раз, когда итератор встречает yield return он возвращает значение. Этот оператор сигнализирует нам и компилятору, что данное выражение – итератор. Задача итератора перемещаться между элементами коллекции и возвращать значение текущего. Многие привыкли</p>
<ul>
    <li>Обратите внимание, что с yield return нам не нужно создавать дополнительный список, чтобы заполнить его значениями. А значит мы получаем экономию памяти, ведь нам требуется лишь память для текущего элемента коллекции. При поэлементной обработке не выделяется память, достаточно кэша.</li>
    <li>Возможность корректировать значения коллекции после выполнения итератора. Так как yield return возвращает элемент коллекции на момент реальной обработки (при отображении значения элемента в консоли, например), то мы можем изменять элементы коллекции даже после выполнения итератора. Ведь итератор на самом деле не возвращает реальные значения, когда вы его вызываете. Итератор знает где взять значения. И он их вернет только тогда, когда они реально потребуются.  Это так называемая Lazy load.</li>
    <li>Обработка исключений с yield return имеет нюансы. Оператор yield return нельзя использовать в секции try-catch, только try-finally.</li>
</ul>

<p>Когда же нужно использовать yield return?</p>
<ul>
    <li>При перечислении объектов. Итератор будет работать быстрее, чем возвращаемая коллекция. Да и накладные расходы памяти ниже;</li>
    <li>В бесконечных циклах. Используя метод Take() вы всегда можете ограничить выборку.</p></li>
</ul>