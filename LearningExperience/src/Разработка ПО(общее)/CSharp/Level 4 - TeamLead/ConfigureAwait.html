<p>Класс SynchronizationContext предназначен для исполнения кода в потоке конкретного вида. В .NET имеются разные контексты синхронизации, но наиболее важны контексты потока пользовательского интерфейса, используемые в WinForms и в WPF</p>
<p>В классе SynchronizationContext есть важный метод <b>Post</b>, который гарантирует, что переданный делегат будет исполняться в правильном контексте.</p>
<p>В каждом подклассе SynchronizationContext метод Post реализован по-своему. Как правило, вызов этого метода обходится сравнительно дорого. Чтобы избежать накладных расходов, .NET не вызывает Post, если запомненный контекст синхронизации совпадает с текущим на момент завершения задачи. </p>
<p>Однако если контексты синхронизации различаются, то необходим дорогостоящий вызов Post. Если производительность стоит на первом месте или речь идет о библиотечном коде, которому безразлично, в каком потоке выполняться, то, возможно, не имеет смысла нести такие расходы. В таком случае следует вызвать метод <b>ConfigureAwait</b> объекта Task, перед тем как ждать его. Тогда при возобновлении исполнения не будет вызываться метод Post запомненного контекста SynchronizationContext</p>
<p><b><i>Однако метод ConfigureAwait не всегда делает то, что вы ожидаете. Он задуман как способ информирования .NET о том, что вам безразлично, в каком потоке будет возобновлено выполнение, а не как неукоснительный приказ.</i></b> Что происходит в действительности, зависит от того, в каком потоке завершилось выполнение ожидаемой задачи. Если этот поток не очень важен, например взят из пула, то исполнение кода в нем и продолжится. Но если поток по какой-то причине важен, то .NET предпочтет освободить его для других дел, а исполнение вашего метода продолжить в потоке, взятом из пула. Решение о том, важен поток или нет, принимается на основе анализа текущего контекста синхронизации.</p>