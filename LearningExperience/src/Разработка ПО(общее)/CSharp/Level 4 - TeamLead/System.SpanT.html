<p></p><h4>Использование ссылок для типов данных хранимых по значению</h4><br>
Для начала стоит вспомнить, что существуют два типа данных:<br>
<br>
<ul>
<li>Хранимые по значению — простые типы данных, такие как int или bool, которые хранятся напрямую в стеке, за счет чего к ним осуществляется быстрый доступ</li>
<li>Хранимые по ссылке — более сложные структуры, такие как string или классы, которые хранятся в куче, а в стеке хранится только указатель на область памяти кучи.</li>
</ul><br>
При этом если значимый тип передавался в метод, то создавалась его новая копия, поэтому изменить изначальную переменную внутри метода было невозможно, если не использовались модификаторы доступа (ref). Но если в метод передавался ссылочный тип, то копирование объекта не выполнялось, и изменение объекта в методе изменяло изначальный объект.<br>
<br>
Здесь заключается одна не очевидная проблема, так как при передаче значимого типа в метод каждый раз создается его новая копия, то возникает замедление работы системы и чрезмерное использование памяти. Особенно это актуально для объемных структур, которые хранятся в стеке. Представьте себе рекурсивный вызов метода, с передачей в качестве аргумента структуры с 20 полями… Поэтому в новой версии языка были предприняты шаги для оптимизации работы с переменными хранимыми по значению.<br>
<br>
Добавлен модификатор in, который указывает, что значимый тип должен передаваться по ссылке, но при этом накладывается ограничение, что он не может быть изменен внутри метода.<br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Sum</span>(<span class="hljs-params"><span class="hljs-keyword">in</span> <span class="hljs-keyword">int</span> value1, <span class="hljs-keyword">in</span> <span class="hljs-keyword">int</span> value2</span>)</span>;</code></pre><br>
Так как структура struct тоже хранится в стеке, для нее добавлено использование модификатор readonly, который по сути является аналогом in<br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">readonly</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> ReadonlyPosition
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReadonlyPosition</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y</span>)</span>
    {
        X = x;
        Y = y;
    }
  
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> X { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Y { <span class="hljs-keyword">get</span>; }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ReadonlyPosition _position = <span class="hljs-keyword">new</span> ReadonlyPosition();
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> ReadonlyPosition Position =&gt; <span class="hljs-keyword">ref</span> _position;
}</code></pre><br>
Добавлен модификатор ref struct, который указывает, что структура передается по ссылке, и должен обрабатываться с выделением стека.<br>
<br>
Также Добавлен модификатор доступа ref readonly, который указывает, что значение возвращается по ссылке, но при этом запрещено изменение соответствующей переменной.<br>
<br>
Ну и наконец был добавлен тип Span&lt;T&gt;,<b> который позволяет создать коллекцию данных, хранимую в стеке, но доступ к которой осуществляется по ссылке.</b> Тип Memory&lt;T&gt; является расширением типа Span&lt;T&gt; и используется для потокобезопасного доступа по ссылке к коллекции хранимой в стеке.<br>
<hr>
<p>Если Span ведет себя внешне как массив, то в чем его преимущество или когда он нам может пригодиться? Рассмотрим простейшую ситуацию - у нас есть массив со значениями дневных температур воздуха 
    за месяц, и нам надо получить их него два набора - набор температур за первую декаду и за последнюю декаду. Используя массивы, мы могли бы сделать так:</p>
    <div><div id="highlighter_243908" class="syntaxhighlighter  c#"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="c# keyword">int</code><code class="c# plain">[] temperatures = </code><code class="c# keyword">new</code> <code class="c# keyword">int</code><code class="c# plain">[]</code></div><div class="line number2 index1 alt1"><code class="c# plain">{</code></div><div class="line number3 index2 alt2"><code class="c# spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c# plain">10, 12, 13, 14, 15, 11, 13, 15, 16, 17,</code></div><div class="line number4 index3 alt1"><code class="c# spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c# plain">18, 16, 15, 16, 17, 14,&nbsp; 9,&nbsp; 8, 10, 11,</code></div><div class="line number5 index4 alt2"><code class="c# spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c# plain">12, 14, 15, 15, 16, 15, 13, 12, 12, 11</code></div><div class="line number6 index5 alt1"><code class="c# plain">};</code></div><div class="line number7 index6 alt2"><code class="c# keyword">int</code><code class="c# plain">[] firstDecade = </code><code class="c# keyword">new</code> <code class="c# keyword">int</code><code class="c# plain">[10];&nbsp;&nbsp;&nbsp; </code><code class="c# comments">// выделяем память для первой декады</code></div><div class="line number8 index7 alt1"><code class="c# keyword">int</code><code class="c# plain">[] lastDecade = </code><code class="c# keyword">new</code> <code class="c# keyword">int</code><code class="c# plain">[10];&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="c# comments">// выделяем память для второй декады</code></div><div class="line number9 index8 alt2"><code class="c# plain">Array.Copy(temperatures, 0, firstDecade, 0, 10);&nbsp;&nbsp;&nbsp; </code><code class="c# comments">// копируем данные в первый массив</code></div><div class="line number10 index9 alt1"><code class="c# plain">Array.Copy(temperatures, 20, lastDecade, 0, 10);&nbsp;&nbsp;&nbsp; </code><code class="c# comments">// копируем данные во второй массив</code></div></div></td></tr></tbody></table></div></div>
    <p>Для хранения данных создаются два дополнительных массива для дневных температур каждой декады. С помощью метода Array.Copy данные из исходного массива 
    temperatures копируются в два остальных массива. Но суть в данном случае в том, что для обоих массивов мы вынуждены выделить память. То есть оба массива 
    по сути содержат те же данные, что и temperatures, однако в отдельных частях памяти.</p>
    <p>Span позволяет работать с памятью более эффективно и избежать ненужных выделений памяти. Так, используем вместо массивов Span:</p>
    <div><div id="highlighter_181032" class="syntaxhighlighter  c#"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="c# keyword">int</code><code class="c# plain">[] temperatures = </code><code class="c# keyword">new</code> <code class="c# keyword">int</code><code class="c# plain">[]</code></div><div class="line number2 index1 alt1"><code class="c# plain">{</code></div><div class="line number3 index2 alt2"><code class="c# spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c# plain">10, 12, 13, 14, 15, 11, 13, 15, 16, 17,</code></div><div class="line number4 index3 alt1"><code class="c# spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c# plain">18, 16, 15, 16, 17, 14,&nbsp; 9,&nbsp; 8, 10, 11,</code></div><div class="line number5 index4 alt2"><code class="c# spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c# plain">12, 14, 15, 15, 16, 15, 13, 12, 12, 11</code></div><div class="line number6 index5 alt1"><code class="c# plain">};</code></div><div class="line number7 index6 alt2"><code class="c# plain">Span&lt;</code><code class="c# keyword">int</code><code class="c# plain">&gt; temperaturesSpan = temperatures;</code></div><div class="line number8 index7 alt1">&nbsp;</div><div class="line number9 index8 alt2"><code class="c# plain">Span&lt;</code><code class="c# keyword">int</code><code class="c# plain">&gt; firstDecade = temperaturesSpan.Slice(0, 10);&nbsp;&nbsp;&nbsp; </code><code class="c# comments">// нет выделения памяти под данные</code></div><div class="line number10 index9 alt1"><code class="c# plain">Span&lt;</code><code class="c# keyword">int</code><code class="c# plain">&gt; lastDecade = temperaturesSpan.Slice(20, 10);&nbsp;&nbsp;&nbsp; </code><code class="c# comments">// нет выделения памяти под данные</code></div></div></td></tr></tbody></table></div></div>
    <p>Для создания производных объектов Span применяется метод Slice, который из Spana выделяет часть и возвращет ее в виде другого объекта Span. 
    Теперь объекты Span firstDecade и lastDecade работают с теми же данными, что и temperaturesSpan, а дополнительно память не выделяется. То есть во всех трех случаях 
    мы работаем с тем же массивом temperatures. Мы даже можем в одном Span изменить данные, и данные изменятся в другом:</p>
    <div><div id="highlighter_70690" class="syntaxhighlighter  c#"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="c# keyword">int</code><code class="c# plain">[] temperatures = </code><code class="c# keyword">new</code> <code class="c# keyword">int</code><code class="c# plain">[]</code></div><div class="line number2 index1 alt1"><code class="c# plain">{</code></div><div class="line number3 index2 alt2"><code class="c# spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c# plain">10, 12, 13, 14, 15, 11, 13, 15, 16, 17,</code></div><div class="line number4 index3 alt1"><code class="c# spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c# plain">18, 16, 15, 16, 17, 14,&nbsp; 9,&nbsp; 8, 10, 11,</code></div><div class="line number5 index4 alt2"><code class="c# spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c# plain">12, 14, 15, 15, 16, 15, 13, 12, 12, 11</code></div><div class="line number6 index5 alt1"><code class="c# plain">};</code></div><div class="line number7 index6 alt2"><code class="c# plain">Span&lt;</code><code class="c# keyword">int</code><code class="c# plain">&gt; temperaturesSpan = temperatures;</code></div><div class="line number8 index7 alt1">&nbsp;</div><div class="line number9 index8 alt2"><code class="c# plain">Span&lt;</code><code class="c# keyword">int</code><code class="c# plain">&gt; firstDecade = temperaturesSpan.Slice(0, 10);</code></div><div class="line number10 index9 alt1">&nbsp;</div><div class="line number11 index10 alt2"><code class="c# plain">temperaturesSpan[0] = 25; </code><code class="c# comments">// меняем в temperatureSpan</code></div><div class="line number12 index11 alt1"><code class="c# plain">Console.WriteLine(firstDecade[0]); </code><code class="c# comments">//25</code></div></div></td></tr></tbody></table></div></div>
    <p>За счет чего это достигается? Для понимания работы Span можно обратиться к исходному коду типа. В частности, мы можем в нем увидеть следующее свойство:</p>
    <div><div id="highlighter_861854" class="syntaxhighlighter  c#"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="c# keyword">public</code> <code class="c# keyword">readonly</code> <code class="c# keyword">ref</code> <code class="c# keyword">struct</code> <code class="c# plain">Span&lt;T&gt;</code></div><div class="line number2 index1 alt1"><code class="c# plain">{</code></div><div class="line number3 index2 alt2"><code class="c# spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c# comments">//....</code></div><div class="line number4 index3 alt1"><code class="c# spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c# keyword">public</code> <code class="c# keyword">ref</code> <code class="c# plain">T </code><code class="c# keyword">this</code><code class="c# plain">[</code><code class="c# keyword">int</code> <code class="c# plain">index] { </code><code class="c# keyword">get</code> <code class="c# plain">{ ... } }</code></div><div class="line number5 index4 alt2"><code class="c# spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c# comments">//....</code></div><div class="line number6 index5 alt1"><code class="c# plain">}</code></div></div></td></tr></tbody></table></div></div>
    <p>Здесь мы видим, что индексатор возвращает ref-ссылку, благодаря чем мы получаем доступ непосредственно к объекту и можем его изменять.</p>
    <p>В данном случае, конечно, преимущества от отсутствия выделения дополнительной памяти под хранение объектов минимальны. Но при более интенсивной работе с данными выигрыш в производительности неизбежно 
    должен возрастать.</p>
    <h3>Методы Span</h3>
    <p>Основные методы Span:</p>
    <ul>
    <li><p><code>void Fill(T value)</code>: заполняет все элементы Span значением value</p></li>
    <li><p><code>T[] ToArray()</code>: преобразует Span в массив</p></li>
    <li><p><code>Span&lt;T&gt; Slice(int start, int length)</code>: выделяет из Span length элементов начиная с индекса start в виде другого Span</p></li>
    <li><p><code>void Clear()</code>: очищает Span</p></li>
    <li><p><code>void CopyTo(Span&lt;T&gt; destination)</code>: копирует элементы текущего Span в другой Span</p></li>
    <li><p><code>bool TryCopyTo(Span&lt;T&gt; destination)</code>: копирует элементы текущего Span в другой Span, но при этом также возвращает значение bool, 
    которое указывает, удачно ли прошла операция копирования</p></li>
    </ul>
    
    <h3>ReadOnlySpan</h3>
    <p>Структура <span class="b">ReadOnlySpan</span> аналогична Span, только предназначена для неизменяющихся данных. Например:</p>
    <div><div id="highlighter_258535" class="syntaxhighlighter  c#"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="c# keyword">string</code> <code class="c# plain">text = </code><code class="c# string">"hello, world"</code><code class="c# plain">;</code></div><div class="line number2 index1 alt1"><code class="c# keyword">string</code> <code class="c# plain">worldString = text.Substring(startIndex: 7, length: 5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="c# comments">// есть выделение памяти под символы</code></div><div class="line number3 index2 alt2"><code class="c# plain">ReadOnlySpan&lt;</code><code class="c# keyword">char</code><code class="c# plain">&gt; worldSpan = text.AsSpan().Slice(start: 7, length: 5); </code><code class="c# comments">// нет выделения памяти под символы</code></div><div class="line number4 index3 alt1"><code class="c# comments">//worldSpan[0] = 'a'; // Нельзя изменить</code></div><div class="line number5 index4 alt2"><code class="c# plain">Console.WriteLine(worldSpan[0]); </code><code class="c# comments">// выводим первый символ</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="c# comments">// перебор символов</code></div><div class="line number8 index7 alt1"><code class="c# keyword">foreach</code><code class="c# plain">(var c </code><code class="c# keyword">in</code> <code class="c# plain">worldSpan)</code></div><div class="line number9 index8 alt2"><code class="c# plain">{</code></div><div class="line number10 index9 alt1"><code class="c# spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c# plain">Console.Write(c);</code></div><div class="line number11 index10 alt2"><code class="c# plain">}</code></div><div class="line number12 index11 alt1"><code class="c# spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;</div></div></td></tr></tbody></table></div></div>
    <p>В данном случае с помощью метода <span class="b">AsSpan()</span> преобразуем строку в объект ReadOnlySpan&lt;char&gt; и затем выделяем из него диапазон символов "world". 
    Поскольку ReadOnlySpan предназначен только для чтения, то соответственно мы не можем изменить через него данные, но получить можем. В остальном 
    работа с ReadOnlySpan идет так же, как с Span.</p>
    <h3>Ограничения Span</h3>
    <p>Как структура, определенная с модификатором ref, Span имеет ряд ограничений: она не может быть присвоена переменной типа Object, dynamic 
    или переменной типа интерфейса. Она не может быть полем в объекте ссылочного типа (а только внутри ref-структур). Она не может использоваться в пределах операций await или yield.</p>