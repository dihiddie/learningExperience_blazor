<p>В C#, подобно любому языку программирования, имеется готовый набор лексем, используемых для выполнения базовых операций над встроенными типами. Например, известно, что операция + может применяться к двум целым, чтобы дать их сумму. Здесь нет ничего нового, но задумывались ли вы когда-нибудь о том, что одна и та же операция + может применяться к большинству встроенных типов данных C#. По сути, функциональность операции + уникальным образом базируются на представленных типах данных (строках или целых в данном случае). Когда операция + применяется к числовым типам, мы получаем арифметическую сумму операндов. Однако когда та же операция применяется к строковым типам, получается конкатенация строк.</p>
<p>Перегрузка операторов тесно связана с перегрузкой методов. Для перегрузки оператора служит ключевое слово <strong>operator</strong>, определяющее операторный метод, который,
в свою очередь, определяет действие оператора относительно своего класса.
Существуют две формы операторных методов (operator): одна - для унарных
операторов, другая - для бинарных. Ниже приведена общая форма для каждой разновидности этих методов: </p>
<div class="construct"><pre><i>// Общая форма перегрузки унарного оператора.
public static возвращаемый_тип operator op(тип_параметра операнд)
{
// операции
}

// Общая форма перегрузки бинарного оператора.
public static возвращаемый_тип operator op(тип_параметра1 операнд1,
тип_параметра2 операнд2)
{
// операции
}</i></pre>
</div>
<p>Здесь вместо op подставляется перегружаемый оператор, например + или /, а <em>возвращаемый_тип</em> обозначает конкретный тип значения, возвращаемого указанной операцией. Это значение может быть любого типа, но зачастую оно указывается такого же
типа, как и у класса, для которого перегружается оператор. Такая корреляция упрощает применение перегружаемых операторов в выражениях. Для унарных операторов
<em>операнд</em> обозначает передаваемый операнд, а для бинарных операторов то же самое
обозначают <em>операнд1</em> и <em>операнд2</em>. Обратите внимание на то, что операторные методы должны иметь оба спецификатора типа - public и static.</p>
<h4>Перегрузка операторов отношения</h4>
<p>Операторы отношения, например == и <, могут также перегружаться, причем очень просто. Как правило, перегруженный оператор отношения возвращает логическое значение true и false. Это вполне соответствует правилам обычного применения подобных операторов и дает возможность использовать их перегружаемые разновидности в условных выражениях.</p>
<h4>Перегрузка операторов true / false</h4>
<p>Операторы true и false должны перегружаться попарно, а не раздельно. Ниже приведена общая форма перегрузки этих унарных операторов: </p>
<div class="construct"><pre><i>public static bool operator true(тип_параметра операнд)
{
// Возврат логического значения true или false.
}

public static bool operator false(тип_параметра операнд)
{
// Возврат логического значения true или false.
}</i></pre>
</div>
<h4>Операторы преобразования</h4>
p>Существуют две формы операторов преобразования: явная и неявная. Ниже они представлены в общем виде:</p>
<div class="construct"><pre><i>public static explicit operator целевой_тип(исходный_тип v) {return значение;}
public static implicit operator целевой_тип(исходный_тип v) {return значение; }</i></pre>
</div>
<p>где <em>целевой_тип</em> обозначает тот тип, в который выполняется преобразование; <em>исходный_тип</em> — тот тип, который преобразуется; значение — конкретное значение,
приобретаемое классом после преобразования. Операторы преобразования возвращают данные, имеющие целевой_тип, причем указывать другие возвращаемые типы данных не разрешается.</p>
<p>Если оператор преобразования указан в неявной форме (<strong>implicit</strong>), то преобразование вызывается автоматически, например, в том случае, когда объект используется
в выражении вместе со значением целевого типа. Если же оператор преобразования
указан в явной форме (<strong>explicit</strong>), то преобразование вызывается в том случае, когда
выполняется приведение типов. Для одних и тех же исходных и целевых типов данных нельзя указывать оператор преобразования одновременно в явной и неявной форме.</p>