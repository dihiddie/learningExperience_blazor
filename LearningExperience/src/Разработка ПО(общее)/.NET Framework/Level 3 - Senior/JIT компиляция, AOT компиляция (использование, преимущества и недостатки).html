<h4>JIT компилятор</h4>
<p>При JIT-компиляции язык MSIL преобразуется в машинный код во время выполнения приложения по требованию, когда загружается и выполняется содержимое сборки.</p>

<p>Когда метод Main первый раз обращается к методу WriteLine, вызывается функция JITCompiler. Она отвечает за компиляцию IL-кода вызываемого метода в собственные команды процессора. Поскольку IL-код компилируется непосредственно перед выполнением («just in time»), этот компонент CLR часто называют JIT-компилятором</p>
<p>Функции JITCompiler известен вызываемый метод и тип, в котором он определен. JITCompiler ищет в метаданных соответствующей сборки IL-код вызываемого метода. <b><i>Затем JITCompiler проверяет и компилирует IL-код в машинные команды, которые сохраняются в динамически выделенном блоке памяти. После этого JITCompiler возвращается к структуре внутренних данных типа, созданной средой CLR, и заменяет адрес вызываемого метода адресом блока памяти, содержащего готовые машинные команды.</i></b> В завершение JITCompiler передает управление коду  в этом блоке памяти. Этот программный код является реализацией метода WriteLine (вариант этого метода с параметром String). Из этого метода управление возвращается в метод Main, который продолжает выполнение в обычном порядке.
<br>Рассмотрим повторное обращение метода Main к методу WriteLine. К этому моменту код метода WriteLine уже проверен и скомпилирован, так что обращение к блоку памяти производится напрямую, без вызова JITCompiler. Отработав, метод  WriteLine возвращает управление методу Main.</p>

<p>Снижение производительности наблюдается только при первом вызове метода. Все последующие обращения выполняются «на максимальной скорости», потому что повторная верификация и компиляция не производятся. JIT-компилятор хранит машинные команды в динамической памяти. Это значит, что скомпилированный код уничтожается по завершении работы приложения. Для повторного вызова приложения или для параллельного запуска его второго экземпляра (в другом процессе операционной системы) JIT-компилятору придется заново скомпилировать IL-код в машинные команды. В зависимости от приложения это может привести к существенному повышению затрат памяти по сравнению с низкоуровневыми приложением, у которых находящийся в памяти код доступен только для чтения и совместно используется всеми экземплярами приложения.</p>

<p>JIT примеры:</p>
<ul>
    <li>В Java JIT находится в JVM (Java виртуальная машина)</li>
    <li>В C# он находится в CLR (Common Language Runtime)</li>
    <li>В Android он находится в DVM (виртуальная машина Dalvik), или ART (Android RunTime) в более новых версиях.</li>
</ul>

<h4>AOT компилятор</h4>
<p>При AOT-компиляции компиляция происходит перед тем, как программа будет запущена, обычно добавляеся как шаг билда.</p>
<p><b>CoreRT - </b>рантайм .NetCore, оптимизированный для сценариев AOT-компиляции с сопровождающим набором инструментов компидятора .Net</p>

<h4>Разница</h4>
<p>Суффикс Time в Ahead-Of-Time и Just-In-Time относится к рантайму. При AOT-компиляции компиляция происходит перед тем, как программа будет запущена, обычно добавляеся как шаг билда. А в JIT-компиляции компиляция происходит во время запуска программы. 
<br>
С точки зрения C# .NET MsBuild, который генерирует CIL используя csc.exe, не знает вообще о том, какой тип компиляции использует CLR. Компилятор вступает в действие во время запуска программы.
<br>AOT компилятор компилирует все сборки (в CIL или любой другой язык) в нативный машинный код до запуска программы. 
<br>Jit-компилятор компилирует отдельные методы и классы (в CIL или любой другой язык) в нативный машинный язык во время вызова методов. И именно по-этому первый прогрев долгий, а остальные - быстрые.</p>

<img src="https://professorweb.ru/my/csharp/charp_theory/level1/files/img4458.png">