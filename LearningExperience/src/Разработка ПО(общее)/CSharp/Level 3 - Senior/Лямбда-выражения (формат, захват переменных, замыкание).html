<p><strong>Лямбда выражения — это безымянные методы, написанные вместо экземпляра делегата.</strong> При компиляции лямбда выражения преобразуются &nbsp;либо в экземпляры делегата либо в дерево выражений, имеющее тип&nbsp;<code>Expression&lt;TDelegate&gt;</code> (это позволяет перевести код выражения в объект и интерпретировать его позже — во время выполнения).</p></strong>
<pre><code>
    delegate int Transformer (int i);
    Transformer sqr = x => x * x;
    Console.WriteLine (sqr(3)); // 9
</code></pre>
<p><b>Лямбда выражения имеют следующую форму:</b></p>
<p><i>(параметры) => выражение-или-блок-инструкций</i></p>
<p>Каждый параметр лямбда выражения соотносится с параметром делегата, а тип выражения (это может быть и void) соотносится с типом, возвращаемым делегатом. В примере выше x соотносится с параметром i, а выражение x * x соотносится с возвращаемым типом int и поэтому совместимо с делегатом Transform.</p>
<p>Вместо выражения в лямбда выражении можно использовать <b>блок инструкций:</b></p>
<i>x => { return x * x; };</i>
<p>Лямбда выражения могут использоваться и с событиями. Например, если предположить, Clicked — это событие типа EventHandler, то можно добавить обработчик с помощью лямбда выражения:</p>
<i>obj.Clicked += (sender,args) => Console.Write ("Click");</i>
<h5>Захват локальных переменных</h5>
<p>В лямбда выражениях могут использоваться внешние переменные —  локальные переменные и параметры метода, в котором эти выражения определяются.</p>
<pre><code>
    static void Main()
    {
        int factor = 2;
        Func<int, int> multiplier = n => n * factor;
        Console.WriteLine (multiplier (3)); // 6
    }</code></pre>

<p><b><i>Внешние переменные, используемые в лямбда выражениях, называются захваченными переменными, а лямбда выражения, захватывающие переменные, называются замыканиями (closure)</i></b>. Захваченные переменные вычисляются не в момент захвата, а в момент, когда вызывается делегат. Лямбда выражения сами могут обновлять захваченные переменные. Время жизни захваченных переменных растягивается до времени жизни делегата. </p>
<h5>Захват переменных цикла</h5>
<p>При захвате переменных цикла for, C# ведет себя с ними так, как будто они объявлены вне цикла. Поэтому на каждой интерации цикла захватывается одна и та же внешняя для цикла переменная. По этой причине в следующем примере мы получим 333, а не 012:</p>
<pre><code>
    Action[] actions = new Action[3];
    for (int i = 0; i < 3; i++)
        actions [i] = () => Console.Write (i);
    foreach (Action a in actions) a(); // 333
</code></pre>
<p>В связи с тем, что делегатs вызываются уже после выполнения цикла for, когда переменная i равна 3, а захваченные переменные, как уже отмечалось, вычисляются на момент вызова делегата, каждый делегат видит значение переменной i на момент его вызова, а это 3.
<br>
Если же нам нужно получить не 333, а 012, то единственным решением является присваивать значение переменной цикла на каждой интерации какой-либо локальной переменной, объявляемой внутри цикла, и захватывать уже эту локальную переменную:
</p>
<pre><code>
for (int i = 0; i < 3; i++)
{
    int loopScopedi = i;
    actions [i] = () => Console.Write (loopScopedi);
}
foreach (Action a in actions) a(); // 012
</code></pre>

<p>Цикл foreach в предыдущих версиях языка работал также как цикл for, но начиная с версии C# 5.0 можно использовать переменные цикла foreach в замыканиях непосредственно, не создавая временных локальных переменных на каждой интерации.</p>