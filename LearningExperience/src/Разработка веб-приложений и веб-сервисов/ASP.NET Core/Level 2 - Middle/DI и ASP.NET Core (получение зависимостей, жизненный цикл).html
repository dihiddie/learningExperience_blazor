<h4>Получение зависимостей</h4>
<p>Рассмотрим четыре шаблона для внедрения зависимости в объект.</p>
<h5>1. Constructor Injection (внедрение через конструктор)</h5>
<p>Constructor Injection это способ внедрения зависимостей, когда необходимые объекты запрашиваются классом как параметры его конструктора.</p>
<h6>Принцип реализации</h6>
<ol>
   <li>Создаем в классе <em>private readonly</em> поле, для хранения ссылки на экземпляр объекта. Указание <em>readonly</em> предохраняет его от случайного изменения в дальнейшем. </li>
   <li>Запрашиваем объект как параметр конструктора. </li>
   <li>Проверяем, что полученное значение не является пустой ссылкой (<em>null</em>). </li>
   <li>Сохраняем в созданном выше поле для дальнейшего использования. </li>
</ol>
<h6>Плюсы</h6>
<ul>
   <li>Очень простой для понимания и использования способ.</li>
</ul>
<h6>Минусы</h6>
<ul>
   <li>В момент создания объекта придется породить экземпляры всех классов, от которых он зависит; </li>
   <li>При наличии нескольких конструкторов необходимо описать логику выбора нужного варианта; </li>
   <li>Возможно потребуется модификация существующего кода для поддержки конструкторов с параметрами. </li>
</ul>
<h5>2. Property Injection (внедрение через свойство)</h5>
<p>При использовании Property Injection объект предоставляет свойства, в которые могут быть переданы экземпляры классов от которых он зависит. </p>
<p>Обратите внимание, данная схема внедрения не носит обязательного характера. Например, разработчик может просто забыть передать зависимость. Для решения данной проблемы может быть использована реализация по умолчанию. Такой подход схож с шаблоном проектирования Стратегия.</p>
<h6>Принцип реализации</h6>
<ul>
   <li>Создаем открытое для записи свойство, в котором будет размещен экземпляр требуемого объекта. </li>
   <li>Хорошей практикой считается создание реализации по умолчанию. Её экземпляр должен быть порожден при первом обращении к свойству, если зависимости не была передана до этого.</li>
</ul>
<h6>Плюсы</h6>
<ul>
   <li>Способ прост в использовании.</li>
   <li>Применим в случае, когда зависимость не может быть передана в момент создания класса. </li>
</ul>
<h6>Минусы</h6>
<ul>
   <li>Нет гарантии что зависимость будет внедрена в объект. </li>
   <li>Необходимость четко определить что будет, если клиентский код попытается передать новый экземпляр или пустую ссылку (<em>null</em>) в процессе работы приложения. </li>
</ul>
<h5>3. Method Injection (внедрение через параметр метода)</h5>
<p>Method Injection подразумевает внедрение зависимости через параметр метода. Стоит отметить, что при каждом обращении может передаваться другой объект, в зависимости от текущего состояния приложения.</p>
<h6>Принцип реализации</h6>
<ul>
   <li>Один из параметров метода используется для передачи зависимости. </li>
   <li>При обращении к методу проверяем, что полученное значение не является пустой ссылкой (<em>null</em>). </li>
   <li>Используем его в процессе выполнения метода. </li>
   <li>Область использования полученного объекта ограничивается данным методом. </li>
</ul>
<h6>Плюсы</h6>
<ul>
   <li>Позволяет передавать зависимость, определяемую текущем контекстом выполнения. </li>
</ul>
<h6>Минусы</h6>
<ul>
   <li>Ограниченная область применения. </li>
</ul>
<h5>4. Ambient Context (фоновый контекст)</h5>
<p>Идея Ambient Context заключается в создании <em>pubic static</em> свойства или метода, предоставляющих экземпляр объекта определенного типа и доступного любому объекту в приложении. По смыслу такой подход применим для зависимостей, предоставляемых framework и прочими глобальными объектами приложения. </p>
<p>Примеры шаблона в .NET: <em>Application.Current</em>, <em>Thread.CurrentCultureand</em>, <em>Thread.CurrentUICulture</em>, <em>System.Web.Http.GlobalConfiguration.Configuration</em>, <em>Microsoft.AspNet.SignalR.GlobalHost.DependencyResolver, <em>OperationContext.Current</em> </em>и т.п.</p>
<p>Необходимо обратить внимание, что Ambient Context, в отличии от шаблона Service Locator, предоставляет объект одного, заранее известного типа. Это напоминает шаблон <a href="/patterns/oop/creational/singleton/">Singleton</a>.</p>
<h6>Принцип реализации</h6>
<ul>
   <li>Создаем <em>pubic static </em>свойство или метод, возвращающие объект заданного типа.</li>
   <li>Порождается экземпляр по умолчанию, даже если клиентский код может установить свой объект. Ambient Context должен быть всегда доступен.</li>
</ul>
<h6>Плюсы</h6>
<ul>
   <li>Всегда доступен.</li>
   <li>Хорошо подходит в ситуации, когда определенная зависимость необходима многим объектам приложения и эти объекты заранее неизвестны.</li>
</ul>
<h6>Минусы</h6>
<ul>
   <li>Неявная зависимость. Чрезмерное увлечение таким подходом может сильно запутать код.</li>
   <li>Сложность в реализации, с учетом многопоточности и других особенностей приложения.</li>
</ul>

<h4>Жизненный цикл</h4>
<ul>
    <li>Transient</li>
    <p>Создаются при каждом вызове. Создаются каждый раз, когда нам требуется экземпляр определенного класса. Хорошо подходят для легковесных приложений. Диспоузятся в конце каждого запроса</p>
    <li>Scoped</li>
    <p>Создаются по одному на каждый запрос. Диспоузятся в конце каждого запроса</p>
    <li>Singleton</li>
    <p>Создаются при первом обращении. Каждый последующий запрос использует тот же экземпляр (т.е. при всех запросах к приложению оно использует один и тот же singleton-объект).  К подобным singleton-объектам относятся, к примеру, компоненты middleware или сервисы, которые регистрируются с помощью метода AddSingleton() Диспоузится, когда ServiceProvider диспоузится при завершении приложения.</p>   
</ul>