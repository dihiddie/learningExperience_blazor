<p>Task служит нескольким целям, но основная из них это "promise" — объект, представляющий возможность ожидать завершение какой-либо операции. Вы инициируете операцию и получаете Task. Этот Task будет завершен, когда завершиться сама операция.Класс Task довольно гибок и имеет ряд преимуществ. Например, вы можете "ожидать" объект этого класса несколько раз, ожидать результата можно конкурентно, любым количеством потребителей, и тд. Но, все же, наиболее частым случаем использования является просто запуск асинхронной операции и дальнейшее ожидания результата ее выполнения. Кроме того, при всех достоинствах, тип Task имеет потенциальный недостаток. Task — это класс, а значит, каждая операция, которая создает экземпляр задачи, аллоцирует объект в куче. Чем больше объектов мы создаем, тем больше требуется работы со стороны GC, и тем больше тратиться ресурсов на работу сборщика мусора, ресурсов, которые могли бы быть использованы на другие цели. Это становится явной проблемой для кода, в котором, с одной стороны, экземпляры Task создаются часто, а с другой, к которому предъявляются повышенные требования по пропускной способности и производительности.</p>
<p>С тех пор, как с C# 5.0 были введены async/await, единственными поддерживыемыми возвращаемыми типами были Task< Tresult >, Task, void. Проблема с этим ограничением состоит в том, что в случаях, когда результат уже известен, все еще необходимо перейти к созданию задачи, даже если для определения результата не требуется никакой задачи.</p>
<p>Рассмотрим функцию, которая возвращает количество места, занятого каким-то путем. Если директория пуста, то мы знаем, что занятый ею размер = 0 и нам не нужна асинхронная операция, чтобы вычислить размер. Однако, так как нащ возвращаемый тип Task< long >, то нам все равно надо его проинициализировать. </p>
<p>C# 7.0 предоставляет возможность создать кастомные возвращаемый тип на async методах. Главное, что надо имплементировать GetAwaiter(). ValueTask (структура) - как раз таки пример такого кастомного типа. Он разработан для того самого случая, когда возвращаемое значение может быть известно сразу - кешируется, например, из предыдущего вызова. Самое интересное, в il коде, несмотря на то, что возвращаемый тип стал ValueTask, внутри он все еще возвращает Task< long ></p>
<a href="https://intellitect.com/generalized-async-return-types/">https://intellitect.com/generalized-async-return-types/</a>
<p><a href="https://habr.com/ru/company/clrium/blog/465259/">https://habr.com/ru/company/clrium/blog/465259/</a></p>