<p> По соглашению, всякий TAP-метод, поддерживающий отмену, должен иметь перегруженный вариант, в котором за обычными параметрами следует параметр типа CancellationToken. </p>
<p>Посмотрим, как отменить вызванный асинхронный метод. Для этого нам понадобится класс CancellationTokenSource, который умеет создавать объекты CancellationToken и управлять ими – примерно так же, как TaskCompletionSource создает и управляет объектами Task. </p>
<p><i>CancellationTokenSource cts = new CancellationTokenSource();<br>
    cancelButton.Click += delegate { cts.Cancel(); };<br>
    int result = await dbCommand.ExecuteNonQueryAsync(cts.Token);<br></i></p>
<p>При вызове метода Cancel объекта CancellationTokenSource тот переходит в состояние «отменен». Мы можем зарегистрировать делегат, который будет вызван в этот момент, но на практике эффективнее гораздо более простой подход, заключающийся в проверке того, что вызывающая программа хочет отменить начатую операцию. Если в асинхронном методе есть цикл и объект CancellationToken доступен, то достаточно просто вызывать на каждой итерации метод     ThrowIfCancellationRequested.</p>
<p>При вызове метода ThrowIfCancellationRequested отмененного объекта CancellationToken возбуждается исключение типа OperationCanceledException. Библиотека Task Parallel Library знает, что такое исключение представляет отмену, а не ошибку, и обрабатывает его соответственно. Например, в классе Task имеется свойство IsCanceled, которое автоматически принимает значение true, если при выполнении async-метода произошло исключение OperationCanceledException.
<br>Удобной особенностью подхода к отмене, основанного на маркерах CancellationToken, является тот факт, что один и тот же маркер можно распространить на столько частей асинхронной операции, сколько необходимо, – достаточно просто передать его всем частям.Неважно, работают они параллельно или последовательно, идет ли речь о медленном вычислении или удаленной операции, – один маркер отменяет всё</p>