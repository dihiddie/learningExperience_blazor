<p>Конструкции синхронизации можно поделить на 4 категории:</p>
<ul>
    <li><b>Простые методы блокировки.</b> <b><i>Суть этих методов в ожидании, когда другой поток завершится.</i></b> Ожидание может быть задано на определенный период времени. К методам простой блокировки относятся Sleep, Join и Task.Wait.</li>
    <li><b>Конструкции критических секций (locking constructs).</b> Это вводит ограничение, что <b><i>определенная секция кода может исполняться в любой момент времени только ограниченным количеством потоков.</i></b> Исключительная блокировка (exclusive locking) встречается чаще всего - она позволяет в любой момент времени только одному потоку осуществлять доступ к общим данным, при этом другие потоки не могут помешать доступу. Стандартные конструкции исключительной блокировки это lock (Monitor.Enter/Monitor.Exit), Mutex и SpinLock. Конструкции не исключительной блокировки (nonexclusive locking) это Semaphore, SemaphoreSlim и блокировки reader/writer.</li>
    <li><b>Конструкции сигнализации (signaling).</b> <b><i>Они позволяют потоку приостановиться, пока не придет оповещение от другого потока</i></b>, что устраняет необходимость не эффективного опроса (каких-то общих флагов или переменных). Есть два используемых обычно устройства сигнализации (signaling devices): обработчики ожидания события (event wait handles) и методы and Wait/Pulse класса Monitor</li>
    <li><b>Не блокирующие конструкции синхронизации.</b><b><i> Они защищают доступ к общему полю путем вызова примитивов процессора.</i></b> Библиотека CLR и язык C# предоставляют следующие не блокирующие конструкции: Thread.MemoryBarrier, Thread.VolatileRead, Thread.VolatileWrite, ключевое слово volatile и класс Interlocked.</li>
</ul>

<h3>Монопольная блокировка</h3>
<p>Исключительная, или монопольная блокировка (exclusive locking) используется, чтобы гарантировать, что только один поток в любой момент времени мог войти в определенную секцию кода.</p>
<h4>lock / Monitor</h4>
<p> lock работает быстрее и более удобен.</p>
<p>Только один поток может в любой момент времени заблокировать объект синхронизации lock. Любые претендующие на доступ к lock-участку кода будут заблокированы, пока блокировка не будет снята (т. е. пока выполнение не выйдет за пределы lock-участка кода). Такой участок кода также называют критической секцией. Если больше одного потока претендуют на доступ к региону кода lock, то они ставятся в очередь готовности (ready queue), и доступ к критической секции будет даваться по принципу FIFO</p>
<p>Оператор lock на C# фактически является "синтаксическим сахаром", т. е. обертками над вызовами методов Monitor.Enter и Monitor.Exit с блоком try/finally. </p>
<p>lock работает быстрее и более удобен, но у Mutex есть ниша, в которой её блокировка может охватить приложения в различных процессах, работающих на компьютере</p>
<p>Любой объект, видимый каждому из участвующих в общей работе потоков, может использоваться в качестве синхронизирующего объекта согласно одному жесткому правилу: это должен быть ссылочный тип (reference type). Синхронизирующий объект обычно имеет область доступа private (потому что это помогает инкапсулировать логику блокировки) и обычно это поле экземпляра или статическое поле.</p>
<h4>Mutex</h4>
<p>Мьютекс подобен C# lock, но он может работать между несколькими процессами. Другими словами, Mutex может действовать как в пределах компьютера, так и в пределах приложения. Так же, как и с оператором lock, Mutex может быть освобожден только в том потоке, который получил этот Mutex.</p>

<h3>Неисключительная блокировка</h3>
<h4>Semaphore</h4>
<p><b>Ограничивает число потоков, которые могут одновременно обращаться к ресурсу или пулу ресурсов.</b></p>
<p>Это объект, который похож на ночной клуб: у него есть определенная емкость, принудительно отслеживаемая вышибалой на входе. Будучи заполненным, клуб больше не может принять посетителей, что создает очередь снаружи. Тогда для каждой уходящей персоны зайдет одна персона из головы очереди. Конструктор семафора требует минимум 2 аргументов: количество доступных в настоящий момент мест и общая емкость семафора.</p>
<p>У семафора нет владельца - он не обращает внимания на потоки. Любой потом может вызвать Release на семафор, в то время как с Mutex или lock, только один поток может получить блокировку и освободить её.</p>
<p><b>Именованный семафор:</b> если семафору задать имя, он будет ассоциирован с семафором операционной системы. Они видны во всей операционной системе и могут быть использованы для синхронизации активности процессов </p>
<p><b>Локальный семафор</b> виден только в рамках вашего процесса.</p>
<h4>SemaphoreSlim</h4>
<p>SemaphoreSlim является упрощенной альтернативой классу Semaphore, который не использует семафоры ядра Windows. Не поддерживает именованные системные семафоры, а значит, не может быть использован для синхронизации между процессами. Класс SemaphoreSlim является рекомендуемым семафором для синхронизации в рамках одного приложения. </p>

<h3>Сигнализация с обработкой ожидания события</h3>
<p>Это способ обмена состоянием, когда один поток ждет поступления оповещения от другого. </p>
<h4>AutoResetEvent</h4>
<p>Представляет событие синхронизации потоков, которое при срабатывании автоматически сбрасывается, освобождая один поток в состоянии ожидания</p>
<p>AutoResetEvent похож на билетный турникет: установка в него билета позволяет пройти через него одному человеку. Префикс auto в имени класса отражает факт, что после открытия турникета он автоматически закрывается, или сбрасывается (reset) после выполнения нескольких шагов.</p>
<p>Событие AutoResetEvent отличается от события типа ManualResetEvent лишь способом установки в исходное состояние. Если для события типа ManualResetEvent событийный объект остается в сигнальном состоянии до тех пор, пока не будет вызван метод Reset(), то для события типа AutoResetEvent событийный объект автоматически переходит в несигнальное состояние, как только поток, ожидающий это событие, получит уведомление о нем и возобновит свое выполнение. Поэтому если применяется событие типа AutoResetEvent, то вызывать метод Reset() необязательно.</p>
<h4>ManualResetEvent</h4>
<p>Представляет событие синхронизации потока, которое при получении сигнала необходимо сбросить вручную. </p>
<p>Разница между ним и AutoResetEvent похоже на дверь и автоматические ворота. AutoResetEvent (автоматические ворота) закроются сами после того, как пропустят одну машину. ManualResetEvent - дверь, которую надо закрыть за собой, после того как ты проехал </p>
<h4>ManualResetEventSlim</h4>
<p>Этот класс можно использовать для лучшей производительности, чем ManualResetEvent, когда ожидается, что время ожидания будет очень коротким, а событие не пересекает границу процесса.</p>
<h4>WaitHandle</h4>
<p>WaitHandle - это абстрактный базовый класс для двух самых используемых дескрипторов событий: AutoResetEvent и ManualResetEvent.</p>
<p><b>WaitOne - </b>используется для ожидания сигнала от другого потока, который указывает, что что-то произошло. WaitOne позволяет заставить текущий поток ждать, пока асинхронная операция не завершится.</p>
<p>WaitAll и WaitAny то статические методы класса WaitHandle, которые позволяют указать массив WaitHandles для ожидания. </p>
<p><b>WaitAll - </b> блокирует, пока все хэндлеры не будут в состоянии Set</p>
<p><b>WaitAny - </b> будет блокировать до тех пор, пока хотя бы один из них не перейдет в состояние Set</p>

<a href="http://microsin.net/programming/pc/threading-in-csharp-part-2-basic-synchronization.html">http://microsin.net/programming/pc/threading-in-csharp-part-2-basic-synchronization.html</a>