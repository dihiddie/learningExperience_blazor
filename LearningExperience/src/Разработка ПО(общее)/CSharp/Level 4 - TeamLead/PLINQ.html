<p>По большей части использование Parallel LINQ, обычно называемого PLINQ, очень похоже на применение LINQ to Object. Фактически это одна из привлекательных сторон PLINQ. В обычном запросе LINQ to Query источником данных является IEnumerable< T >, где T — обрабатываемый тип данных. Механизм LINQ автоматически переключается на использование PLINQ, когда источником данных является экземпляр типа ParallelQuery< T >. И здесь есть один трюк: любой IEnumerable< T > может быть преобразован в ParallelQuery< T > просто с использованием метода AsParallel.</p>
<p>Данные, представленные в качестве источника для запроса PLINQ, разбиваются на части и разделяются для параллельной обработки. Несколько разделов могут обрабатываться одновременно. Однако каждый из этих разделов обрабатывается последовательно. Задумайтесь об этом - параллельное выполнение происходит из последовательной обработки нескольких разделов данных одновременно</p>
<p>PLINQ назначает один раздел для обработки одному из ядер машины, и каждое ядро обрабатывает назначенный ему раздел последовательно</p>
<p>PLINQ генерирует результаты, которые не упорядочены так, как исходные данные. Хуже того, поскольку заранее не известно то, как PLINQ разобьет данные, то и нельзя предсказать, каким будет порядок. Еще хуже то, что разделы не обрабатываются за один шаг. Другие процессы на машине могут приостанавливать выполнение приложения .NET на одном или более ядер, а это означает, что в действительности при многократном запуске одного и того же запроса будут получены результаты, упорядоченные по-разному. Чтобы сохранить порядок, необходимо воспользоваться расширяющим методом AsOrdered на объекте ParallelQuery, который создан посредством метода AsParallel.</p>
<p>Можно потребовать, чтобы PLINQ ограничивал количество разделов, обрабатываемых параллельно, с использованием расширяющего метода WithDegreeOfParallelism, который работает с типом ParallelQuery. Этот метод принимает аргумент int, который устанавливает максимальное количество разделов, которые должны быть обработаны одновременно; это называется степенью параллелизма.

    Установка степени параллелизма не принуждает PLINQ использовать именно столько разделов, а лишь указывает верхний предел. PLINQ может решить использовать меньшее количество разделов, чем указано, или же, если метод WithExecutionMode не использовался, может вообще выполнять запрос последовательно.</p>
    <p>PLINQ собирает все исключения, которые находит, и упаковывает их в System.AggregateException, которое затем генерирует в коде.Класс AggregateException имеет метод Handle, позволяющий обрабатывать каждое исключение по очереди. Ему передается исключение и возвращается true, если оно обработано, либо false, если обработать исключение не удается. Если исключение не обрабатывается, оно распространяется дальше и в конечном итоге прекращает работу программ</p>