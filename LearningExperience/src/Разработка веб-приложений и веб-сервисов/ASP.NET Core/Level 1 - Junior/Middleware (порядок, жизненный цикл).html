<p>Мы можем создавать свои компоненты middleware в виде отдельных классов, которые затем добавляются в конвейер с помощью метода UseMiddleware()</p>
<p>Класс middleware должен иметь <b>конструктор, который принимает параметр типа RequestDelegate</b>. Через этот параметр можно получить ссылку на тот делегат запроса, который стоит следующим в конвейере обработки запроса.
<br>Также в классе должен быть определен метод, который должен называться<b> либо Invoke, либо InvokeAsync</b>. Причем этот метод должен возвращать объект Task и принимать в качестве параметра контекст запроса - объект HttpContext. Данный метод собственно и будет обрабатывать запрос.</p>
<p>Чтобы добавить миддлвару надо: в стартап в Configure метод добавить следующее:</p>
<p><i>app.UseMiddleware< TokenMiddleware >();</i></p>
<p>Или можно написать метод расширения над IApplicationBuilder, чтобы было удобно:</p>
<pre><code>
public static class TokenExtensions
{
    public static IApplicationBuilder UseToken(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware&lt;TokenMiddleware&gt;();
    }
}
</code></pre>
<p>И в стартап: <i>app.UseToken();</i></p>
<p>В миддлвару можно передавать параметры в конструктор: <i>return builder.UseMiddleware< TokenMiddleware >(<b>parameter</b>);</i></p>
<h4>Конвейер обработки запроса</h4>
<p>Как правило, для обработки запроса применяется не один, а несколько компонентов middleware. И в этом случае большую роль может играть порядок их помещения в конвейер обработки запроса, а также то, как они взаимодействуют с другими компонентами. Кроме того, каждый компонент middleware может обрабатывать запрос до и после последующих в конвейере компонентов. Данное обстоятельство позволяет предыдущим компонентам корректировать результат обработки последующих компонентов.</p>
<p><b><i>Каждый компонент обрабатывает запрос два раза: вначале вызывается та часть кода, которая идет до await _next.Invoke(context);, а после завершения обработки последующих компонентов вызывается та часть кода, которая идет после await _next.Invoke(context);.</i></b></p>

<p>Разница меджу миддлварой и фильтрами:</p>
<ul>
    <li>Миддлвара</li>
    <ul>
        <li>У миддлвары есть доступ к HttpContext, который позволит вам выполнять действия как с запросом, так и с ответом, но нет доступа до ActionExecutedContext, как в случае фильтра действия.</li>
        <li>Поскольку привязка модели еще не произошла при работе с миддлварой, использование промежуточного программного обеспечения не подходит для запуска функции проверки или изменения значений.</li>
        <li>Будет запускаться при каждом запросе независимо от того, какой контроллер или действие вызывается.</li>
    </ul>    
</ul>