<h4>LOH</h4>
<p>Для объектов, размер которых превышает определенный порог (85 000 байт), сборщик мусора использует отдельную область, называемую хипом для больших объектов — Large Object Heap, LOH. Большие объекты способны быстро заполнить поколение Gen0, и при отсутствии LOH сборка мусора для этого поколения запускалась бы чаще, снижая производительность. 
<br>Область LOH не подвержена сжатию, т.к. перемещение больших объектов является ресурсоемким. По этой причине выделение памяти под новые объекты является более медленным, т.к. сборщик мусора должен просматривать свободные участки памяти. Кроме того LOH подвержена фрагментации.
<br>LOH не поддерживает концепцию поколений: все объекты рассматриваются как относящиеся к поколению Gen2.</p>

<h4>Уведомления о сборке мусора</h4>
<p>Серверная версия CLR может отправлять уведомления непосредственно перед началом полной сборки мусора. Это позволяет переадресовывать запросы на другой сервер на время проведения сборки мусора.</p>
<p>Метод RegisterForFullGCNotification позволяет зарегистрироваться для получения уведомлений о приближении полной сборки мусора. Вы получите два уведомления: при приближении полной сборки мусора и по ее завершении.</p>

<h4>Слабая ссылка</h4>
<p>Иногда бывает желательно сохранить невидимой строку, связанную с объектом, не мешая при этом сборщику мусора удалить объект из памяти. Когда сборщик мусора удалит объект, строка окажется не связанной ни с каким объектом, и мы сможем определить это. Если сборщик мусора еще не прикасался к объекту, с помощью этой строки мы сможем восстановить сильную ссылку на объект и использовать его снова. <b>Отличается от строгих ссылок тем, что сборщик мусора не учитывает связь ссылки и объекта в куче при выявлении объектов, подлежащих удалению.</b> Таким образом слабая ссылка позволяет работать с объектом как и строгая ссылка, но при необходимости объект будет удален, даже при наличии слабой ссылки на него. Обычные ссылки в контексте сборки мусора иногда именуют «сильными».</p>
<p>Могут использоваться в</p>
<ul>
    <li>Таймеры и события могут предоставляться объектам без сохранения ссылок на них, что может способствовать устранению типичных причин утечки памяти.</li>
    <li>Удержание больших объектов в надежде, что они не будут утилизированы. Приложение может хранить слабую ссылку на большой объект, для создания и инициализации которого требуется много времени. Если объект окажется уничтожен сборщиком мусора, приложение сможет повторно создать его; в противном случае его можно использовать повторно.</li>
    <li>Автоматическое управление стратегией кеширования или поддержания пула объектов. Кеш может хранить слабые ссылки на недавно использовавшиеся объекты, не мешая их утилизации; пул может быть разделен на две части - основную, минимального размера, хранящую сильные ссылки, и дополнительную, содержащую слабые ссылки.</li>
</ul>